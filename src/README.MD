Spring puzzlers by E Borisov
тонкости и нюансы работы String
grabbed from conferention Joker<?> 2015

# Часть 1, простой пример о том, как Спринг обрабатывет аннотации наследников
Есть 2 класса, Parent и Son extends Parent
в обоих метод 
    @PostConstruct
    init()
который печатает папу или сына
С помощью Спринга создаем объект из сына

ВОПРОС: 
    создаем Сына, что будет с методом init() у Папы?
ВАРИАНТЫ:
    -@PostConstruct не inherited (не наследуемая - ^почему?), поэтому ПНП
    -init() у Папы private, поэтому Спринг не сможет его запустить,  ПНП
    -не может быть больше чем один init-метод, ПНП
    -init() переопределем у сына, ПНП
    -Папа придёт

ОТВЕТ:
...Папа пришёл, почему?
в Java аннотации в любом случае не перходят по наследству, но никто не мешает фреймворку их где-то поискать. Открываем документацию на @PostConstruct - там написано, что она можетдаже ставиться над методами private, и находиться у наследников. Во-первых из-за того, что у родителя private, тоникакого оверрайда нету, поэтому у нас реально два метода init(). И Спринг рекурсивно проходит по всем родителям вплотьдо Object и делает getDeclaredMethods() и запускает все методы помеченные @PostConstruct, поэтому сработают оба метода

^а что если будут оба private? Все равно работает
^ а что если оба public? Приходит только Сын, ^почему?

# Часть 2, самописные аспекты

Можно не использовать аспекты Спринга, т к они медленнные,да  и не сложно

У нас класс JokerCongServiceImpl implements JokerCongService{
В него инжкетим String conference

в @PostConstruct порисходит какой-то setup()
и естьь метод pay() помеенный аннотацие @Audit

Мы хотим написать кастомный Аспект, который для всех методов, аннотированных @Audit будет что-то делать.
Для этого понадобится BPP, который инжектит какой-то AuditManager, и в beforeInitialization берет пришедший в него бин, прохоит по всем егометодам,если какой-тотаннотирован @Audit, у всемкому нашел, добавляет логику с помощбью dynamicProxy (dynamic работает через интерфейсы). Далее сначала вызываем оригинальный метод на оригинальный объект, затем процессим покупку билета auditManager.audit(retVal), и потом возвращаем результат ориг метода... вот это все внутри postProcessBeforeInitialization

Вернемся в наш класс, у которого есть метод pay(), аннотированный @Audit, который приведет ктому что прокси создасть\ся, и каждый раз когда он вызывается, будет срабатывать та логика из auditManager...

ВОПРОС: 

Мы вытаскиваем бин из контекста,запускаем этот метод pay()
Что произойдет?

ВАРИАНТЫ:
    не сработает setup()
    исключение noSuchBeanDefinitionException
    упадет @Autowired, потому что у прокси уже не будет нужного филда
    все будет хорошо

пробуем. . .
...у меня не инжектится conference с помощью @Autowired, пришлось инжектить через xml-контекст
...как и auditManager
запускаем... 
и у нас не срабатывает метод setup(). Что является правильным ответом.
Это происходит из-затого,что неправильтно написан AuditBPP
Спринг протаскивает все наши объекты через все БПП, делая это в 3 этапа: 
    -все бины проходят через beforeInit()
    -потом во всех бинах вызывается инит-метод
    -и затем все бины проходят через afterInit() всех  BPP 

В нашем примере если бин аннотирован @Audit, то на этапе -beforeInit() наш AuditBPP возвращает Прокси с измененным методом pay(). Но в Прокси уже нет никаких аннотаций, поэтому PostConstruct на методе setup() не будет вызван.

Решение в том, чтобы перенести всю логику с прокси из beforeInitialization() в afterInitialization(), при этом прокси будут накручиваться на 

^Это кстати очень важно, этот контракт в Спринге надо понимать:
если мы настраиваем объект, то логика должна быть написана в методе beforeInit(), потому что init-метод должен иметь возможность оперировать всем тем, что инжектит Спринг. И к тому же, если наш BPP настраивает сам бин, то хотелось бы, чтобы в инит-методе вся нужная информация была. 
Но если наш БПП не настраивает бин, а меняет поведение его методов путем создания прокси, это нужно делать в методе after() который отрабатываетпосле init() именно для того, чтобы его не убить.

...чиним..
все работает.

# ЧАСТЬ 3, добавляем настоящий спринговый аспект
//таймкод 10:30

Все же решили добавить настояий спринг-аспект,дляэтого написан класс PayInformatorAspect аннотированный @Aspect
На методе allPayMethods() определён @Pointcut, в котором при помощи регулярок говорится, что мы хотим инструментировать все методы, которые начинаются на слово "pay", у нас в приложении как раз один такой есть.
        @Pointcut("execution(* jokerconf..*.pay*(..))")
        afterAllMethods(){}

и еще после этого мы хотим чтобы посылалось уведомление,что прожан ещеодин билет
        @After("allPayMethods()")
        public void sendMailToManager(){
            Sout ("еще один билет прдали");
        }

ВОПРОС: что произойдет, когда наш BPP, который делает прокси, схлестнется со аспектом Спринга, который тоже делает прокси  

ВАРИАНТЫ
-менеджер получит извещение,но не бюужет аудита,потому что отывалится BPP
-Аудит будет (BPP сработает), менеджер не узнает о проданном билете, тк отвалится аспект Спринга
-оба прокси сработают
-бужет exception из-за двух уровней прокси

запускаем,
сначалааспектвообщене сработал,это изза того что я когфигурировал через xml
прописал аспекты в xml:
    -неймспейс, схемалокейшн
    <aop-config> и тут все что было на аннотациях. 

в итоге работает аспект, а самописный аспект на BPP работать перестал
что и является правильным ответом

это происходит потому,что..."когда мы а BPP ищем по getClass() "
когда  мы делаем getClass, хорошо если мы получим ориг класс,Ювкоторм есть всек пнашли аннотации
но в даномслукчае getClass() возврашщает нам прокси,который накрутио предыдущий BPP или пред аспект,посколькуСпринг заботится отом,чятобы его апекты отрабатывали до наших BPP
поэтому наш BPP не находит аннотации @Audit и не рабоатет
Решение втом, чтобы не писать bean.getClass() когда мы пишем свой BPP. чтобы не завязываться на bean.getClass() надо в методе before() запомнить ориг класс в мапу, а в методе after() вытаскиваем изэтой мапы этот класс, а значит мы его запомнили,потому что там была аннотация, значит можно  делать прокси (см. доклад "Спринг-Потрошитель" Е.Борисова)

^повторим? надо переписать BPP
