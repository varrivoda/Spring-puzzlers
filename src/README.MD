Spring puzzlers by E Borisov
тонкости и нюансы работы String
grabbed from conferention Joker<?> 2015

# Часть 1, простой пример о том, как Спринг обрабатывет аннотации наследников
Есть 2 класса, Parent и Son extends Parent
в обоих метод 
    @PostConstruct
    init()
который печатает папу или сына
С помощью Спринга создаем объект из сына

ВОПРОС: 
    создаем Сына, что будет с методом init() у Папы?
ВАРИАНТЫ:
    -@PostConstruct не inherited (не наследуемая - ^почему?), поэтому ПНП
    -init() у Папы private, поэтому Спринг не сможет его запустить,  ПНП
    -не может быть больше чем один init-метод, ПНП
    -init() переопределем у сына, ПНП
    -Папа придёт

ОТВЕТ:
...Папа пришёл, почему?
в Java аннотации в любом случае не перходят по наследству, но никто не мешает фреймворку их где-то поискать. Открываем документацию на @PostConstruct - там написано, что она можетдаже ставиться над методами private, и находиться у наследников. Во-первых из-за того, что у родителя private, тоникакого оверрайда нету, поэтому у нас реально два метода init(). И Спринг рекурсивно проходит по всем родителям вплотьдо Object и делает getDeclaredMethods() и запускает все методы помеченные @PostConstruct, поэтому сработают оба метода

^а что если будут оба private? Все равно работает
^ а что если оба public? Приходит только Сын, ^почему?

# Часть 2, самописные аспекты

Можно не использовать аспекты Спринга, т к они медленнные,да  и не сложно

У нас класс JokerCongServiceImpl implements JokerCongService{
В него инжкетим String conference

в @PostConstruct порисходит какой-то setup()
и естьь метод pay() помеенный аннотацие @Audit

Мы хотим написать кастомный Аспект, который для всех методов, аннотированных @Audit будет что-то делать.
Для этого понадобится BPP, который инжектит какой-то AuditManager, и в beforeInitialization берет пришедший в него бин, прохоит по всем егометодам,если какой-тотаннотирован @Audit, у всемкому нашел, добавляет логику с помощбью dynamicProxy (dynamic работает через интерфейсы). Далее сначала вызываем оригинальный метод на оригинальный объект, затем процессим покупку билета auditManager.audit(retVal), и потом возвращаем результат ориг метода... вот это все внутри postProcessBeforeInitialization

Вернемся в наш класс, у которого есть метод pay(), аннотированный @Audit, который приведет ктому что прокси создасть\ся, и каждый раз когда он вызывается, будет срабатывать та логика из auditManager...

ВОПРОС: 

Мы вытаскиваем бин из контекста,запускаем этот метод pay()
Что произойдет?

ВАРИАНТЫ:
    не сработает setup()
    исключение noSuchBeanDefinitionException
    упадет @Autowired, потому что у прокси уже не будет нужного филда
    все будет хорошо

пробуем. . .
...у меня не инжектится conference с помощью @Autowired, пришлось инжектить через xml-контекст
...как и auditManager
запускаем... 
и у нас не срабатывает метод setup(). Что является правильным ответом.
Это происходит из-затого,что неправильтно написан AuditBPP
Спринг протаскивает все наши объекты через все БПП, делая это в 3 этапа: 
    -все бины проходят через beforeInit()
    -потом во всех бинах вызывается инит-метод
    -и затем все бины проходят через afterInit() всех  BPP 

В нашем примере если бин аннотирован @Audit, то на этапе -beforeInit() наш AuditBPP возвращает Прокси с измененным методом pay(). Но в Прокси уже нет никаких аннотаций, поэтому PostConstruct на методе setup() не будет вызван.

Решение в том, чтобы перенести всю логику с прокси из beforeInitialization() в afterInitialization(), при этом прокси будут накручиваться на 

^Это кстати очень важно, этот контракт в Спринге надо понимать:
если мы настраиваем объект, но логика должна быть написана в методе beforeInit(), потому что init-метод должен иметь возможность оперировать всем тем, что инжектит Спринг. И к тому же, если наш BPP настраивает сам бин, то хотелось бы, чтобы в инит-методе вся нужная информация была. 
Но если наш БПП не настраивает бин, а меняет поведение его методов путем создания прокси, это нужно делать в методе after() который отрабатываетпосле init() именнодля того,чтобыего не убить.

...чиним..
все работает.

